---
layout: default
title: "Knapsack Problem"
parent: Algorithm
nav_order: 2
---

# Knapsack Problem

배낭의 무게에 맞춰서 최선의 가치로 아이템을 담는 방법이다.

물건은 저마다 무게와 가치가 있다.

배낭에는 담을 수 있는 한도 무게가 있다.

이경우 최선의 가치를 내는 방법은 무엇일까?

S = {item1,item2,item3}

wi = 아이템의 무게

pi = 아이템의 가치

W = 배낭의 한도 무게

---

## 문제를 푸는 방법

Brute-Force알고리즘

1. 모든 부분집합을 구해서 가치를 비교한다. -> 연산 시간이 너무 많이 든다. 2의 n승이다.

그리디 알고리즘

2. 가치 기준으로만 판단하여 값을 구한다. -> 가치는 높은데 무게가 많이 나가는 경우가 있다.

    무게가 작은 순으로 시작해도 마찬가지이다.

3. 무게당 가격의 비율로 값을 구한다. -> 이 경우에도 예외가 존재한다.

    아이템을 자르는 것을 허용한다면 optimal이 된다.

    자르는 것을 할 수없다면 남는 공간의 존재 때문에 무조건 optimal은 아니다.

---

## DP를 이용한 문제풀이

편법을 이용한 방법 이다.

가치와 무게를 전부 배열로 만들고 값이 있는 경우에만 가치 값을 넣어준다.

i는 물건 w는 무게이다.

그래서 빈 공간이 많을 수 있다.

DP를 이용해서 문제를 풀 경우 2의 n승의 시간 복잡도를 가진다.

처음 P[0][w], P[i][0] 는 전부 0으로 초기화해준다.

P[i][w] = 

만약 wi <= W 이면 max(P[i-1][w], pi + p[i-1][w-wi])

만약 wi > W 이면 P[i-1][w] 해서 배열을 채워서 값을 구하면 된다.